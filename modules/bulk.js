// source: https://github.com/sequelize/sequelize/issues/4324#issuecomment-131235059


// True if the model has a non-autogenerated primary key
// const has_actual_primary_key = (model) => {
//   const attrs = Object.keys(model.attributes)
//   const pk_fields = attrs.filter( (x) => {
//     return model.attributes[x].primaryKey && !model.attributes[x]._autoGenerated
//   })
//   return pk_fields.length>0
// }

// Uses true "upsert" if the model has a primary key, otherwise findOrCreate().
// const bulk_upsert = (model, rows) => {
//   return Promise.all(rows.map( (row) => {
    // if(has_actual_primary_key(model)) {
    //   return model.upsert(row, {
    //     fields: ["name"]
    //   })
    // } else {
    //   return model.findOrCreate({
    //     where: row,
    //     defaults: row
    //   })
    // }
    // ===

let models = require('../models')

module.exports = {
  findOrCreate: function(model, rows, attrs){
    return Promise.all(rows.map(row=>{
      return model.findOne({
        where: row,
        attributes: attrs
      })
      .then(data=>{
        if (!data) {
          return model.create(row)
        }
        else {
          return data.dataValues
        }
      })
    }))
  },
  upsert: function(model, rows, keys, attrs){
    return Promise.all(rows.map((row, idx)=>{
      return model.findOne({
        where: keys[idx],
        attributes: attrs
      })
      .then(data=>{
        if (!data) {
          return model.create(row)
        }
        else {
          return model.update(row, {
            where: keys
          })
          .then(affectedRow=>{
            return data.dataValues
          })
        }
      })
    }))
  },

  itemUpsert: async function(model, rows, keys, attrs){
    var transaction
    try {
      transaction = await models.sequelize.transaction()
      var errors = []
      for (var i = 0; i < rows.length; i++){
        try {
          var rowData = await model.findOne({
            where: keys[i],
            transaction
          })
          if (!rowData) {
            var rowCreated = await model.create(rows[i])
          }else {
            var keyForQuery = ""
            Object.keys(keys[i]).forEach(idx=>{
              keyForQuery += '"' + idx + '"=' + "'" + keys[i][idx] + "'"
            })
            var query = 'UPDATE "'+ model.getTableName() +'" SET "code" = ?, "sizeId" = ?, "skuId" = ?, "barcode" = ? WHERE ' + keyForQuery + ';'
            var rowUpdated = await models.sequelize.query(query, {
              replacements: [rows[i].code, rows[i].sizeId, rows[i].skuId, rows[i].barcode],
              type: models.sequelize.QueryTypes.UPDATE
            })
          }
        }catch (e) {
          errors.push(e)
        }
      }
      return new Promise((resolve, reject)=>{
        if (errors.length) {
          reject(errors)
        }
        else {
          resolve(rows.length)
        }
      })
    } catch (e) {
      return e
    }
  }
}
