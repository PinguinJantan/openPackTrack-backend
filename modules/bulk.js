// source: https://github.com/sequelize/sequelize/issues/4324#issuecomment-131235059


// True if the model has a non-autogenerated primary key
// const has_actual_primary_key = (model) => {
//   const attrs = Object.keys(model.attributes)
//   const pk_fields = attrs.filter( (x) => {
//     return model.attributes[x].primaryKey && !model.attributes[x]._autoGenerated
//   })
//   return pk_fields.length>0
// }

// Uses true "upsert" if the model has a primary key, otherwise findOrCreate().
// const bulk_upsert = (model, rows) => {
//   return Promise.all(rows.map( (row) => {
    // if(has_actual_primary_key(model)) {
    //   return model.upsert(row, {
    //     fields: ["name"]
    //   })
    // } else {
    //   return model.findOrCreate({
    //     where: row,
    //     defaults: row
    //   })
    // }
    // ===

let models = require('../models')
const logger = require('./log');

module.exports = {
  findOrCreate: function(model, rows, attrs, desc = ''){
    console.log('rows', rows);
    return Promise.all(rows.map(row=>{
      return model.findOne({
        where: row,
        attributes: attrs
      })
      .then(data=>{
        if (!data) {
          return model.create(row).then(created => {
            const { createdAt, updatedAt, ...dataValues } = created.dataValues;
            logger.logData(
              {},
              dataValues,
              logger.operation.CREATE,
              model.tableName,
              dataValues.id,
              desc || 'bulk findOrCreate',
              null,
              null,
            );
            return created;
          })
        }
        else {
          return data.dataValues
        }
      })
    }))
  },
  upsert: function(model, rows, keys, attrs, desc = ''){
    console.log('rows', rows);
    return Promise.all(rows.map((row, idx)=>{
      return model.findOne({
        where: keys[idx],
        attributes: attrs
      })
      .then(data=>{
        if (!data) {
          return model.create(row).then(created => {
            console.log('[created]', created);
            const { createdAt, updatedAt, ...dataValues } = created.dataValues;
            logger.logData(
              {},
              dataValues,
              logger.operation.CREATE,
              model.tableName,
              dataValues.id,
              desc || 'bulk upsert create',
              null,
              null,
            );
            return created;
          })
        }
        else {
          return model.update(row, {
            where: keys,
            returning: true,
          })
          .then(([affectedRow, rows])=>{
            rows.forEach(row => {
              const { createdAt, updatedAt, ...dataValues } = row.dataValues;
              const { createdAt: createdAt2, updatedAt: updatedAt2, ...prevValues } = data.dataValues;
              logger.logData(
                prevValues,
                dataValues,
                logger.operation.UPDATE,
                model.tableName,
                dataValues.id,
                desc || 'bulk upsert update',
                null,
                null,
              );
            })
            return data.dataValues
          })
        }
      })
    }))
  },

  itemUpsert: async function(model, rows, keys, desc = ''){
    var transaction
    try {
      transaction = await models.sequelize.transaction()
      var errors = []
      for (var i = 0; i < rows.length; i++){
        try {
          var rowData = await model.findOne({
            where: keys[i],
            transaction
          })
          if (!rowData) {
            var rowCreated = await model.create(rows[i])
            // log
            const { createdAt, updatedAt, ...dataValues } = rowCreated.dataValues;
            logger.logData(
              {},
              dataValues,
              logger.operation.CREATE,
              model.tableName,
              dataValues.id,
              desc || 'bulk upsert create',
              null,
              null,
            );
          } else {
            var keyForQuery = ""
            Object.keys(keys[i]).forEach(idx=>{
              keyForQuery += '"' + idx + '"=' + "'" + keys[i][idx] + "'"
            })
            var query = 'UPDATE "'+ model.getTableName() +'" SET "code" = ?, "sizeId" = ?, "skuId" = ?, "barcode" = ? WHERE ' + keyForQuery + ';'
            var rowUpdated = await models.sequelize.query(query, {
              replacements: [rows[i].code, rows[i].sizeId, rows[i].skuId, rows[i].barcode],
              type: models.sequelize.QueryTypes.UPDATE,
              model,
            })
            const { createdAt, updatedAt, ...prevValues } = rowData.dataValues;
            const dataValues = {
              id: prevValues.id,
              code: rows[i].code,
              sizeId: rows[i].sizeId,
              skuId: rows[i].skuId,
              barcode: rows[i].barcode,
            }
            console.log(dataValues, 'prev', prevValues)
            logger.logData(
              prevValues,
              dataValues,
              logger.operation.UPDATE,
              model.tableName,
              dataValues.id,
              desc || 'bulk upsert update',
              null,
              null,
            );
            console.log('upd', rowUpdated)
          }
        }catch (e) {
          errors.push(e)
        }
      }
      return new Promise((resolve, reject)=>{
        if (errors.length) {
          reject(errors)
        }
        else {
          resolve(rows.length)
        }
      })
    } catch (e) {
      return e
    }
  }
}
